# DICTIONARIES

USEFULL DATA TYPE KOJI MI OMOGUCAVA DA STORE-UJEM DATA U OBLIKU: KEY -> VALUE PAIRS

**SAMO IMMUTABLE TYPES MOGU BITI KEY-OVI** DOK BOTH MUTABLE AND IMMUTABLE TYPES MOGU BITI VALUES 

**MOGU RECI I TO DA DICTIONARIS PRIHVATAJU SAMO HASHABLE KLJUCEVE, A SAMO SU IMMUTABLE TYPE-OVI TI CIJI VALUE JE HASHABLE**

TO SI SAZNAO I ONDA KADA SI SE BAVIO SET-OVIMA, JER U NJIMA SE SAMO MOGU PROSLEDJIVATI HASHABLE TYPE-OVI KAO ITEMI

**DAKLE I OVDE SE UNDER THE HOOD KORISTI HASH FUNCTION**

DICTIONARI KORISTIM KADA ZELIM DA SAM U MOGUCNOSTI DA QUICKLY ACCESS-UJEM NEKI VALUE, KOJI JE ASSOCIATED SA PARTICULAR KEY

PRACTICAL APPLICATION OF DICTIONARY JESTE NA PRIMER JSON ILI NESTO POPUT MEMOIZACIJE

CHECKING TO SEE IF A KEY IS IN DICTIONARY JESTE ISTO BRZO, KAO KADA SE KOD SET-OVA PROVERAVA DA LI JE ITEM INSIDE, I SVE ZBOG TE HASHABLE OSOBINE

NE PROVERAVA SE KEY ONE BY ONE, VEC SE KORISTI HASH, KAO STO SE NI KOD SETA PROVERAVA ITEM ONE BY ONE, VEC SE KORISTI HASH

# PRAVLJANJE EMPTY DICTIONARY-JA

TO SAM VEC JEDNOM RADIO, MISLECI NA PRVU DA SAM NAPRAVIO EMPTY SET (CISTO TI NAPOMINJEM DA SE EMPTY SET JEDINO PRAVI SA `set({})` ILI `set()` ILI `set([])`)

EVO OVO TI JE EMPTY DICTIONARY

```py
>>> my_dict = {}
>>> my_dict
{}
>>> type(my_dict)
<class 'dict'>
```

POSTOJI I DRUGI NACIN, A TO JE KORISCENJE `dict` KLASE

```py
>>> my_dict = dict()
>>> my_dict
{}
>>> type(my_dict)
<class 'dict'>
```

**OBICNO SE KLASA, ODNOSNO METHOD, CESTO NE KORISTI**

# ZA DICTIONARY SU CURLY BRACKETS (`{}`) VAZNE; DOK SU ZA SET ONE BILE TAKORECI OPCIONE

SADA CU NAPRAVITI NEKOLIKO DICTIONARY-JA

```py
>>> {"kevin": 8, "John": 12}
{'kevin': 8, 'John': 12}
```

```py
>>> {1: "Kevin", 2: "John"}
{1: 'Kevin', 2: 'John'}
```

```py
>>> {8: 8, 6: 6}
{8: 8, 6: 6}
```

```py
>>> {1: [], "Stavros": ("john", "yhree", "oliver")}
{1: [], 'Stavros': ('john', 'yhree', 'oliver')}
```

# ZNAS DA CE DODCI DO ERROR-A ALI POKUSAJ DA STAVIS MUTABLE TYPE KAO KEY

CISTO DA VIDIM KAKAV CE ERROR BITI THROWN

```py
>>> {{"Kevin"}: 8}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'set'
```

DOBIO SI TYPE ERROR JER SI KORISTIO SET KAO KEY

# SECAS SE DA JE TUPLE IMMUTABLE; ON ZAISTA MOZE DA BUDE KLJUC

```py
>>> {(1 , "Mike", 4): "Kevin"}
{(1, "Mike", 4): 'Kevin'}
```

NE ZNAM KOLIKO JE OVO HELPFUL, ALI FUNKCIONISE

# KAO STO JE REC SA ITEMIMA SETA, TAKO I KEYS INSIDE DICTIONARY NISU ORDERED

ODNOSNO ONI NEMAJU RELATED INDEX

# ACCESSING VALUE WITH A KEY

```py
>>> my_dict = {8: "Stavros", "Nick": 4}
>>> my_dict[8]
'Stavros'
>>> my_dict["Nick"]
4
```

KORISTIM `[]` ZA ACCESSING

# AKO POKUSAS DA ACCESS-UJES DICTIONARY "BY POSITION", ODNOSNO DA KORISTIS BROJ

PA BROJ JE VALIDAN KEY, I DOBICES VALUE ASSOCIATED WITH THAT NUMBER KEY

A AKO NEMA ZADATOG KLJUCA, DOBICES **KEY ERROR**

```py
>>> my_dict = {8: "Stavros"}
>>> my_dict[8]
'Stavros'
>>> my_dict[1]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 1
```


